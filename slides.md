---
marp: true
theme: unicorn-day
size: 16:9
paginate: true
footer: "AWS Unicorn Day 2026"
---

<!-- _class: title -->
<!-- _paginate: false -->
<!-- _footer: "" -->

---

<!-- _class: speaker -->
<!-- _paginate: false -->
<!-- _footer: "" -->

# 바이브 코딩으로 완성하는 AWS 서버리스 OpenClaw
## 아이디어 하나로 프로덕션급 시스템을 3일 만에 구축한 이야기

<div class="speaker-info">

**정도현**
수석 컨설턴트
로보코

</div>

---

# 오늘의 이야기

> 아이디어 하나에서 출발해 **3일 만에**
> 프로덕션급 서버리스 인프라를 구축한 이야기

<br>

| 순서 | 주제 | 시간 |
|:---:|------|:---:|
| 1 | **아이디어에서 구현까지** — 바이브 코딩으로 빠르게 만드는 법 | 7분 |
| 2 | **속도와 안정성** — 다계층 검증이 두 마리 토끼를 잡는 비결 | 7분 |
| 3 | **무엇이 가능해지는가** — 결과와 비즈니스 임팩트 | 6분 |

---

# OpenClaw이란?

### 오픈소스 자율형 AI 에이전트 플랫폼

<div class="columns">
<div>

**단순 챗봇이 아닌 실행형 에이전트**

- **계획 → 실행 → 완료 확인** 워크플로우
- 파일 읽기/쓰기, 브라우저 조작, 터미널 명령 실행
- 하트비트 엔진으로 **능동적 모니터링** (크론, 웹훅)
- **영구 메모리** — 장기 상태 및 작업 히스토리 유지

</div>
<div>

**멀티 채널 & 멀티 LLM**

- Telegram, Discord, Slack, WhatsApp 등 **15개+** 채널
- Claude, GPT, Gemini, DeepSeek 등 **LLM 자유 선택**
- **100개+** AgentSkills (브라우저, 스마트홈, 미디어...)
- **675K** 줄 TypeScript, 로컬 퍼스트 아키텍처

</div>
</div>

<br>

> 단순 보조 도구를 넘어 **디지털 동료(Digital Coworker)** 로 진화하는 AI

---

# 시작은 하나의 아이디어

<div class="columns">
<div>

### 요건

- OpenClaw는 자신의 **PC에서 실행** — 강력하지만 제약 존재
  - PC가 꺼지면 사용 불가 (가용성)
  - 외부 접근 시 보안 위험
  - PC안의 모든 리소스에 접근 가능 (권한 관리 어려움)
- 이동 중에도 사용할 수 있도록 **클라우드에 올려보자!**

</div>
<div>

### 그런데...

- 하루 **1-2시간** 만 사용, 나머지 **22시간은 유휴**
- EC2 상시 운영: 월 **$37** (t3.medium)
- Fargate 상시 운영: 월 **$35** (0.5 vCPU)
- 22시간 유휴 비용을 내고 싶지 않다!

</div>
</div>

<br>

> "강력한 보안을 유지하면서, 최소한의 비용으로 프라이빗 OpenClaw 환경 구축. 이 아이디어를 **바이브 코딩** 으로 구현하면?"

---

<!-- _class: lead -->

# Part 1
# 아이디어에서 구현까지

---

# 바이브 코딩이란?

> "I just see things, say things, run things, and copy-paste things,
> and it mostly works."
> — **Andrej Karpathy** (2025.02)

<br>

### 코드를 직접 쓰지 않고, AI와 대화하며 시스템을 구축하는 개발 방식

<br>

토니 스타크가 쟈비스와 함께 아이언맨 수트를 만드는 것처럼,
개발자가 **AI 코딩 에이전트** 와 함께 복잡한 시스템을 설계하고 구현

- "이 프로젝트를 서버리스로 만들기 위한 PRD를 작성하기 위해 인터뷰를 진행해줘"
- "비용 최적화를 극한까지 하고 싶어. Fargate Spot + API Gateway 조합을 조사해줘"
- "CDK 스택 간 순환 참조를 해결해줘"

---

# Idea → Implementation → Learning

### 바이브 코딩의 핵심 사이클

```
  ┌──────────┐     ┌──────────────┐     ┌──────────┐
  │  Idea    │────→│Implementation│────→│ Learning │
  │ (아이디어)│     │   (구현)      │     │  (학습)   │
  └──────────┘     └──────────────┘     └──────────┘
       ↑                                      │
       └──────────── 빠른 반복 ────────────────┘
```

<br>

| 사이클 | Idea | Implementation | Learning |
|--------|------|----------------|----------|
| **비용** | "월 $1로 운영 가능할까?" | NAT GW 제거, Spot, API GW | Secrets Manager도 $2/월 → SSM 마이그레이션 |
| **콜드 스타트** | "126초는 너무 길다" | 9단계 최적화 (Docker, 병렬화, zstd) | v2026.2.14 호환성 깨짐 → 버전 피닝 |
| **사용성** | "웹과 텔레그램 컨테이너가 따로?" | OTP 기반 Identity Linking | IDOR 방지: unlink는 Web-only |

> 이 사이클을 **빠르게** 돌릴수록, **더 큰 비즈니스 기회** 가 열린다

---

# 3일간의 구축 과정

```
2/8 ━━━━━━━━ 2/9 ━━━━━━━━━━━━━ 2/12 ━━━━━━━ 2/16
설계        MVP 구현        콜드 스타트 최적화     문서화
```

| Phase | 기간 | 산출물 |
|-------|------|--------|
| **설계** | 2/8  | PRD, 아키텍처, 구현 계획, 비용 분석, 보안 모델 |
| **MVP 구현** | 2/9 | 10단계 구현, 198 UT + 28 E2E, 전체 인프라 |
| **최적화** | 2/12 | 콜드스타트 4분→1분 미만, 프리워밍, 모니터링 |

> 여러 프로젝트를 진행하면서 사이드 프로젝트로서 설계 하루, 구현 **대부분 하루** — 바이브 코딩의 압도적 생산성

---

# 인터뷰 기반 설계

### AI와의 인터뷰로 PRD 작성 → 명확한 설계 방향과 구현 계획 수립

> "AI가 당신에게 뭘 해줄지 묻기 전에, 여러분이 AI에게 무엇을 제공해야 하는지를 물어보십시오."

```
개발자: "이 프로젝트의 PRD를 작성해줘. PRD 작성을 위해서 필요한 인터뷰를 진행해줘."
AI: "알겠습니다. 먼저 몇 가지 질문을 드리겠습니다.
     1. 이 프로젝트의 주요 목표는 무엇인가요?
     2. 어떤 AWS 서비스를 사용할 계획인가요?
     3. 보안 요구사항은 어떻게 되나요?
     4. 비용 최적화에 대한 우선순위는 어떻게 되나요?"
```

> 개발자는 **의사결정** 에 집중, AI가 **구현의 복잡성** 을 흡수

---

# 점진적 구현: 10단계로 나눠 빠르게 반복

**각 단계마다 목표/산출물/검증 기준을 명확히** → AI가 정확하게 구현

```
Step 1-1: 프로젝트 초기화 (모노레포, TypeScript, CDK 스켈레톤)
Step 1-2: 인프라 기반 (NetworkStack, StorageStack, DynamoDB 5개)
Step 1-3: OpenClaw 컨테이너 (Bridge 서버, JSON-RPC 클라이언트)
Step 1-4: Gateway Lambda (7개 핸들러, 5개 서비스)
Step 1-5~7: CDK 스택 (Auth, Compute, Api)
Step 1-8: Web Chat UI (React SPA, Cognito 인증)
Step 1-9: Telegram Bot (웹훅, 응답 라우팅)
Step 1-10: 통합 테스트 & 문서화
```

Claude Code **Skills** 로 각 단계의 컨텍스트를 자동 주입:

```bash
/implement 1-3   # → Step 1-3의 목표, 산출물, 검증 기준 로드
```

> "한 번에 전체를 만들지 않는다" — **작게 나누고, 빠르게 검증하고, 반복**

---

# 완성된 아키텍처

```
  사용자
   ├── Web Chat UI (S3 + CloudFront)
   └── Telegram Bot
         │
    API Gateway (WebSocket + REST)
         │
    Lambda x 7 (라우팅, 인증, 컨테이너 관리)
         │
    ECS Fargate (온디맨드)
    ┌─────────────────────────┐
    │  Bridge :8080 (HTTP)    │
    │       ↕                 │
    │  OpenClaw GW :18789 (WS)│
    └─────────────────────────┘
         │
    DynamoDB x 5  /  S3  /  SSM
```

**8개 CDK 스택**: Secrets → Network → Storage → Auth/Compute → Api → Web/Monitoring

---

<!-- _class: lead -->

# Part 2
# 속도와 안정성의 비결

---

# AI 시대 개발의 딜레마

### AI가 빠르게 코드를 생성하지만...

<br>

<div class="columns">
<div>

### 빠르기만 하면?

- AI가 NAT Gateway를 기본 포함
  → 월 **$33** 추가 비용
- `launchType` + `capacityProviderStrategy` 동시 지정
  → **런타임 에러**
- OpenClaw v2026.2.14 호환성 깨짐
  → **서비스 장애**

</div>
<div>

### 안정적이기만 하면?

- 모든 코드를 수동 리뷰
  → 생산성 **80% 하락**
- 배포 전 수동 검증
  → 피드백 루프 **수일**
- 보수적 아키텍처 선택
  → 혁신 기회 **상실**

</div>
</div>

<br>

> 해답: **다계층 자동 검증** — AI의 속도를 유지하면서 안정성을 확보

---

# 다계층 검증 파이프라인

### 속도와 안정성의 두 마리 토끼를 잡는 비결

```
AI가 코드 생성
  │
  ├─ Layer 1. TDD ─────────────── 테스트 먼저 작성 → 구현 → 통과 확인
  │
  ├─ Layer 2. pre-commit Hook
  │     ├─ TypeScript build ───── 타입 검증 (컴파일 타임 안전성)
  │     ├─ ESLint ─────────────── 코드 스타일 + 잠재 버그
  │     └─ vitest ─────────────── 198개 단위 테스트 (기능 정합성)
  │
  ├─ Layer 3. pre-push Hook
  │     └─ E2E 테스트 ──────────── 28개 CDK synth 검증 (인프라 정합성)
  │
  ├─ Layer 4. README.md ────────── 제약 조건 ("NAT GW 금지", "비용 $1 이내")
  │
  └─ Layer 5. Skills ──────────── /cost, /security 체크리스트 자동 주입
```

> AI가 생성한 코드도 **반드시 모든 계층을 통과** 해야 커밋 가능

---

# Layer 1: TDD — 서버리스의 생명줄

### 서버리스 = 분산 시스템 → 작은 변경이 전체에 영향

```
개발자: "ws-connect Lambda 핸들러를 만들어줘"

AI: 1. 먼저 테스트 작성 (JWT 검증, 커넥션 저장, 에러 처리)
    2. 핸들러 구현
    3. 테스트 통과 확인
    4. pre-commit 훅이 자동 검증
```

<br>

| 검증 시점 | 실행 | 차단 |
|----------|------|------|
| **pre-commit** | `build` + `lint` + `vitest` (198 UT) | 테스트 실패 시 커밋 차단 |
| **pre-push** | E2E 테스트 (28 CDK synth) | 인프라 불일치 시 푸시 차단 |

> TDD가 **AI의 속도를 안전한 속도** 로 만든다

---

# Layer 4-5: AI에게 제약을 주는 기술

### 3계층 컨텍스트 구조


| 검증 계층 | 추가 비용 | 효과 |
|----------|---------|------|
| **README.md** (제약 조건) | $0 | "NAT Gateway 금지", "비용 $1 이내", "시크릿 디스크 미저장", "TDD 필수" → AI의 의사결정 기준 명시 |
| **Skills** (도메인 지식) | $0 | `/implement`: 단계별 구현 가이드 / `/cost`: 비용 검증 / `/security`: 보안 체크리스트 → 자동 주입 |
| **MEMORY.md** (누적 학습) | $0 | 142개+ 교훈 자동 누적 → "v2026.2.14는 broken", "launchType 금지" 같은 실수 재발 방지 |



> AI가 한 번 실수한 것은 MEMORY.md에 기록되어 **다시 반복하지 않는다**

---

# 실전: 콜드 스타트 해결 과정

### Idea → Implementation → Learning 4회전

```
1회전: "첫 응답까지 126초나 걸린다" (Idea)
  → CPU 업그레이드 0.25→1 vCPU (Implementation)
  → 120s→68s, 하지만 아직 부족 (Learning)

2회전: "Docker 이미지가 2.2GB나 된다" (Idea)
  → AWS CLI 제거(-358MB), chown 최적화(-134MB), zstd 압축 (Implementation)
  → 이미지 43% 감소, -2.5s 추가 절감 (Learning)

3회전: "ECS 프로비저닝 25초를 줄일 수 없나?" (Idea)
  → S3+History 병렬화, IP discovery 비동기화 (Implementation)
  → -3~5s, 하지만 근본적 한계 존재 (Learning)

4회전: "프로비저닝 자체를 없애면?" (Idea)
  → EventBridge 예측적 프리워밍 (Implementation)
  → 0초 달성! 비용 +$0.07/월 (Learning)
```

> 각 회전마다 **측정 → 분석 → 구현 → 검증** — 다계층 검증이 빠른 반복을 가능하게 함

---

# 실전: CDK 크로스 스택 디커플링

### AI가 해결한 실제 인프라 문제

**문제**: ComputeStack과 ApiStack 간 CloudFormation 순환 참조

```
ComputeStack ──exports──→ ApiStack
     ↑                       │
     └───── imports ──────────┘   ← 순환!
```

**AI의 해결책**: SSM Parameter Store 기반 디커플링

```
ComputeStack ──writes──→ SSM Parameter ──reads──→ ApiStack
```

**무중단 마이그레이션 5단계**:
1. SSM 파라미터 수동 생성
2. ApiStack `--exclusively` 배포 (import 제거)
3. 수동 SSM 삭제
4. ComputeStack 배포 (SSM 자동 생성)
5. ApiStack 재배포 (새 값 적용)

> E2E 테스트가 각 단계의 정합성을 보장 → **대담한 리팩토링도 안전하게**

---

# 바이브 코딩 + 서버리스 = 시너지

### 왜 이 조합이 빠른 반복에 유리한가?

| 서버리스의 특성 | 빠른 반복에 유리한 이유 |
|----------------|---------------------|
| **잘 문서화된 빌딩 블록** | AI가 API 문서를 학습 → 정확한 코드 생성 |
| **CDK = 코드형 인프라** | 인프라도 TypeScript → AI가 자연스럽게 생성 + TDD 가능 |
| **명확한 컴포넌트 경계** | Lambda 함수 단위 독립 구현 + 단위 테스트 가능 |
| **즉시 배포** | `cdk deploy` 한 줄로 전체 인프라 반영 |

<br>

> AWS 서비스 조합의 복잡성을 **AI가 흡수** 하고,
> 개발자는 **아이디어와 의사결정에 집중**

---

<!-- _class: lead -->

# Part 3
# 무엇이 가능해지는가

---

# 프로젝트 성과

<div class="columns">
<div>

### 기술 성과

| 항목 | 결과 |
|------|------|
| 월 운영 비용 | **$0.27 ~ $1.11** |
| 콜드 스타트 | **0초** (프리워밍) |
| 보안 계층 | **6계층** ($0 추가 비용) |
| 단위 테스트 | **198개** |
| E2E 테스트 | **28개** |
| CDK 스택 | **8개** |

</div>
<div>

### 개발 성과

| 항목 | 결과 |
|------|------|
| 설계 | 1일 (2/8) |
| MVP 구현 | **대부분 하루** (2/9) |
| 최적화 | 5일 (2/12~16) |
| 총 커밋 | 64개 |
| Claude 세션 | 28개 (98MB 로그) |
| 문서화 | 8개 문서 |

</div>
</div>

---

# 핵심: 빠른 반복이 만드는 비즈니스 기회

### 아이디어만 있으면, AI의 힘을 빌려 빠르게 프로토타이핑

<br>

```
전통적 접근:        아이디어 ──(수주)──→ 설계 ──(수주)──→ 구현 ──(수주)──→ 검증
                   "이것도 가능할까?"    "어떻게?"        "얼마나?"

바이브 코딩 접근:    아이디어 ──(1일)──→ 설계+구현 ──(수일)──→ 최적화
                   "해보자!"           "AI와 함께!"        "더 좋게!"
```

<br>

- **비용 검증**: "월 $1 가능할까?" → 3가지 결정으로 **$0.27/월 달성** → 다음 아이디어로
- **기술 검증**: "콜드 스타트 해결 가능할까?" → 9단계 최적화로 **0초 달성** → 다음 아이디어로
- **제품 검증**: "웹+텔레그램 통합 가능할까?" → OTP Identity Linking **구현 완료** → 다음 아이디어로

> 빠른 반복 = **실패 비용 최소화** + **학습 속도 극대화** = **압도적 비즈니스 찬스**

---

# 다계층 검증이 가능하게 하는 것

### 속도만으로는 부족하다 — 검증된 속도가 진짜 무기

<br>

| 검증 없는 빠른 개발 | 다계층 검증 + 빠른 개발 |
|-------------------|---------------------|
| AI가 만든 코드에 NAT GW 포함 → 비용 폭발 | `/cost` 스킬이 자동 차단 |
| 타입 에러 누적 → 런타임 장애 | pre-commit이 빌드 시점에 차단 |
| 인프라 변경 → CDK synth 실패 | pre-push E2E가 즉시 발견 |
| 서비스 간 통합 오류 → 배포 후 발견 | 198 UT + 28 E2E가 사전 검증 |
| 같은 실수 반복 → 시간 낭비 | MEMORY.md에 교훈 누적 |

<br>

> **빠르게 달리되, 넘어지지 않는 것** — 그것이 다계층 검증의 가치

---

# 핵심 교훈 3가지

<br>

### 1. 아이디어가 있다면, 일단 시작하라

> 설계 하루, 구현 대부분 하루 — AI가 있으면 **아이디어의 실현 가능성** 을 빠르게 검증할 수 있다.
> 비용도, 기술도, 시장도 — **만들어 보면 안다**.

### 2. 다계층 검증은 속도의 전제조건

> TDD + Git Hooks + README.md + Skills + MEMORY.md = 자동 품질 검증.
> 이 파이프라인이 있어야 AI의 속도가 **안전한 속도** 가 된다.

### 3. Idea → Implementation → Learning을 빠르게 돌려라

> 한 번에 완벽하게 만들려 하지 말고, **작게 만들고, 빠르게 검증하고, 배우고, 반복** 하라.
> 이 사이클이 빠를수록 **비즈니스 기회** 가 커진다.

---

# 향후 계획

### 더 깊은 서버리스화

```
현재: Lambda (라우팅) ──→ Fargate (OpenClaw 전체)

목표: Lambda (라우팅 + Control Plane) ──→ 최소 Container (실행만)
      ├── config/sessions API → Lambda + DynamoDB
      ├── cron 스케줄링 → EventBridge + Lambda
      └── 에이전트 실행 → 최소 컨테이너
```

### 도전 과제

- OpenClaw Gateway의 상시 WebSocket 서버 의존성
- 에이전트 실행 최대 10분 (Lambda 15분 제한과의 긴장)
- 로컬 파일시스템 의존 (SQLite 벡터 스토어)

> 이것도 **Idea → Implementation → Learning** 사이클로 해결해 나갈 예정

---

<!-- _class: closing -->
<!-- _paginate: false -->
<!-- _footer: "" -->

# 감사합니다

<br>

### Q&A

<br>

**정도현**
AWS Unicorn Day 2026
